<table id="booktable" class="table dataTable stripe">
  <thead>
    <tr>
      <th>Title</th>
      <th>Language</th>
      <th>Tags</th>
      <th>Word count</th>
      <th>Status stats</th>
      <th>Actions</th>
    </tr>
  </thead>
</table>

{# Hidden form for archive, unarchive, delete. #}
<form id="actionposter" method="post" action="">
</form>

<script>

  /* The book listing. */
  var book_listing_table;

  let setup_text_datatable = function(initial_search) {
    book_listing_table = $('#booktable').DataTable({
      {% if status != 'Archived' %}
      "language": {
            "emptyTable": "No books available. <a href='/book/new'>Create one?</a>"
      },
      {% endif %}
      responsive: true,
      select: true,
      lengthMenu: [ 10, 25, 50 ],
      pageLength: 25,
      paging: true,
      info: true,
      searching: true,
      processing: true,
      serverSide: true,
      stateSave: true,
      search: { search: initial_search },
      columnDefs: [
        {
          "name": "BkTitle", "targets": 0, "width": "40%",
          "render": function ( data, type, row, meta ) {
            const bkid = parseInt(row[3]);
            const pgnum = parseInt(row[10]);
            const pgcount = parseInt(row[8]);
            let pgfraction = '';

            const completed = (parseInt(row[11]) == 1);
            let book_title_classes = ['book-title'];
            if (completed) {
              book_title_classes.push('completed_book');
            }
            else if (pgnum > 1) {
              pgfraction = ` (${pgnum}/${pgcount})`;
            }

            return `<a class="${book_title_classes.join(' ')}" href="/read/${bkid}">${row[0]}${pgfraction}</a>`;
          }
        },
        { "name": "LgName", "targets": 1, },
        { "name": "TagList", "targets": 2, },

        { "targets": 3,
          "data": null,
          "searchable": false,
          "orderable": false,
          "width": "8%",
          "render": function ( data, type, row, meta ) {
            const bookId = row[3];
            let ret = `<span title="${row[9]} unique words on the current page">${row[5]}</span>`;
            return ret;
          }
        },
        { "targets": 4,
          "data": null,
          "searchable": false,
          "orderable": false,
          "width": "30%",
          "createdCell": (td, cellData, rowData, row, col) => $(td).addClass("status-bar-td"),
          "render": function ( data, type, row, meta ) {
            let ret;
            const bookId = row[3];
            const sd = JSON.parse(`${row[12]}`);
            if (sd == null) {
              ret = `<div class="status-bar-container status-bar-container-empty" title="Stats calculated after opening the book"><em>N/A</em></div>`
            }
            // hide individual percent bars if the value is less than 1 percent
            // hide the percentage label if the value is less than 6 percent (because of less space)
            // show rounded value on the label, use truncated version for flex value
            // show the actual value in the tooltip
            else {
              ret = `<div class="status-bar-container">
              <div class="status-bar0 status-bar" title="Unknown: ${sd[0].toFixed(2)}%" style="flex: ${sd[0].toFixed(2)}; display:${sd[0] < 1 ? "none": "inline-flex"}"><span>\xa0${sd[0] > 6 ? Math.round(sd[0]) + '%': ""}</span></div>
              <div class="status-bar1 status-bar" title="New: ${sd[1].toFixed(2)}%" style="flex: ${sd[1].toFixed(2)}; display:${sd[1] < 1 ? "none": "inline-flex"}"><span>\xa0${sd[1] > 6 ? Math.round(sd[1]) + '%': ""}</span></div>
              <div class="status-bar2 status-bar" title="Status 2: ${sd[2].toFixed(2)}%" style="flex: ${sd[2].toFixed(2)}; display:${sd[2] < 1 ? "none": "inline-flex"}"><span>\xa0${sd[2] > 6 ? Math.round(sd[2]) + '%': ""}</span></div>
              <div class="status-bar3 status-bar" title="Status 3: ${sd[3].toFixed(2)}%" style="flex: ${sd[3].toFixed(2)}; display:${sd[3] < 1 ? "none": "inline-flex"}"><span>\xa0${sd[3] > 6 ? Math.round(sd[3]) + '%': ""}</span></div>
              <div class="status-bar4 status-bar" title="Status 4: ${sd[4].toFixed(2)}%" style="flex: ${sd[4].toFixed(2)}; display:${sd[4] < 1 ? "none": "inline-flex"}"><span>\xa0${sd[4] > 6 ? Math.round(sd[4]) + '%': ""}</span></div>
              <div class="status-bar5 status-bar" title="Status 5: ${sd[5].toFixed(2)}%" style="flex: ${sd[5].toFixed(2)}; display:${sd[5] < 1 ? "none": "inline-flex"}"><span>\xa0${sd[5] > 6 ? Math.round(sd[5]) + '%': ""}</span></div>
              <div class="status-bar99 status-bar" title="Well known (+ Ignored): ${sd[99].toFixed(2)}%" style="flex: ${sd[99].toFixed(2)}; display:${sd[99] < 1 ? "none": "inline-flex"}"><span>\xa0${sd[99] > 6 ? Math.round(sd[99]) + '%': ""}</span></span>
              <div>`;
            }
            return ret;
          }
        },
        {
          "targets": 5,
          "data": null,
          "searchable": false,
          "orderable": false,
          "render": function ( data, type, row, meta ) {
            // TODO zzfuture fix: security - add CSRF token
            const ret = [];
            const bkid = row[3];
            const bktitle = encodeURIComponent(row[0]);
            if (row[4] == 0) {
              // not archived
              ret.push(`<img src="{{ url_for('static', filename='icn/document--pencil.png') }}" title="Edit" onclick="edit_book(${bkid})" />`);
              ret.push(`<img src="{{ url_for('static', filename='icn/inbox-download.png') }}" title="Archive" onclick="confirm_archive(${bkid})" />`);
            }
            else {
              ret.push(`<img src="{{ url_for('static', filename='icn/inbox-upload.png') }}" title="Unarchive" onclick="confirm_unarchive(${bkid})" />`);
            }
            ret.push(`<img src="{{ url_for('static', filename='icn/minus-button.png') }}" title="Delete" data-bktitle="${bktitle}" data-bkid="${bkid}" onclick="confirm_delete(this)" />`);
            return ret.join('&nbsp;');
          }
        },

        /* Extra data that is returned in the row for rendering, but not shown. */
        { "name": "BkID", "targets": 6, "data": null, "visible": false },
        { "name": "BkArchived", "targets": 7, "data": null, "visible": false },
        { "name": "WordCount", "targets": 8, "data": null, "visible": false },
        { "name": "UnknownCount", "targets": 9, "data": null, "visible": false },
        { "name": "UnknownPercent", "targets": 10, "data": null, "visible": false },
        { "name": "PageCount", "targets": 11, "data": null, "visible": false },
        { "name": "DistinctCount", "targets": 12, "data": null, "visible": false },
        { "name": "PageNum", "targets": 13, "data": null, "visible": false },
        { "name": "IsCompleted", "targets": 14, "data": null, "visible": false },
        { "name": "StatusDistribution", "targets": 15, "data": null, "visible": false },
      ],

      // Ajax call
      ajax: {
        url: "/book/datatables/{{ status or 'active' }}",
        type: "POST",
        dataType: "json"
      },

    });

  } // end setup_text_datatable


  $(document).ready(function () {
    setup_text_datatable("{{ initial_search or '' }}");
  });

  function do_action_post(action, bookid) {
    let f = $('#actionposter');
    f.attr('action', `/book/${action}/${bookid}`);
    f.submit();
  }

  function confirm_archive(bookid) {
    do_action_post('archive', bookid);
  }

  function confirm_unarchive(bookid) {
    do_action_post('unarchive', bookid);
  }

  //  function confirm_reparse(bookid) {
  //    if (!confirm(`Reparse the book using parsing rules defined for its language.  This will also reset you to the first page of the book.  Click OK to proceed, or Cancel.`)) {
  //      return;
  //    }
  //    do_action_post('reparse', bookid);
  //  }

  function edit_book(bookid) {
    document.location = `/book/edit/${bookid}`;
  }

  function confirm_delete(el) {
    const booktitle = decodeURIComponent($(el).data('bktitle'));
    const bookid = $(el).data('bkid');
    if (!confirm(`Deleting "${booktitle}".  Click OK to proceed, or Cancel.`)) {
      return;
    }
    do_action_post('delete', bookid);
  }

  /**
   * Clearing the state is required for acceptance tests,
   * because otherwise state is accidentally applied to
   * following tests, messing up test results.
   * I tried various things such as setting and clearing
   * the filter input box, but this was the only method
   * that worked reliably.
   * This is called from the lute_test_client.py.
   */
  function clear_datatable_state() {
    book_listing_table.state.clear();
  }
</script>